---
description: Global architectural rules for the Diabetes App (Flutter + FastAPI + Supabase)
globs: ["**/*.dart", "**/*.py", "**/*.sql", "**/*.cypher"]
alwaysApply: true
---

# ðŸ©º Singapore Diabetes App - Architectural Rules

## 1. Core Technology Stack
- **Frontend:** Flutter (Mobile).
  - State Management: `flutter_riverpod` (v2.x).
  - Networking: `dio` (Strictly no `http`).
  - Navigation: `go_router`.
- **Backend:** Python (FastAPI).
  - Runtime: Python 3.11+.
  - validation: `pydantic` (v2.x).
- **Database:** Supabase (PostgreSQL) for relational data.
- **Graph Knowledge:** Neo4j (via `neo4j-driver`) for Medical GraphRAG.
- **LLM Orchestration:** `langchain` and `langgraph`.

## 2. Cross-Language Data Sync (CRITICAL)
- **Source of Truth:** The Python Pydantic models in `backend/app/schemas/` are the master definition.
- **Generation Rule:** When creating a data model (e.g., `PatientContext`), YOU must:
  1. Define it in Python first (inheriting from `BaseModel`) in `backend/app/schemas/`.
  2. Immediately generate the corresponding Dart class in `frontend/lib/models/`.
  3. The Dart class must implement `fromJson` and `toJson` that match the Pydantic schema exactly.

## 3. Agent Architecture (Backend)
The backend is split into specialized Agents. Do not put all logic in `main.py`.
- **Router Agent:** Decides intent (Medical vs. Lifestyle vs. GraphRAG vs. ChitChat).
- **Lifestyle Analyst:** Uses `pandas` to analyze:
  - `glucose_readings` (reading, timing, notes, created_at)
  - `activity_logs` (duration_minutes, intensity, created_at)
  - `weight_logs` (weight, unit, created_at)
  - `medication_logs` (medication_name, quantity, created_at)
  - `meal_logs` (meal, description, created_at)
  - `profiles` (first_name, last_name, age, sex, ethnicity, height, activity_level, location)
  - `conditions` (condition_name)
  - `medications` (medication_name)
- **GraphRAG Agent:** Queries Neo4j medical knowledge graph for:
  - Drug-drug interactions
  - Drug-food interactions
  - Evidence-based recommendations from guidelines
  - Medical paper citations
- **Cultural Dietitian:** Uses Vision API to analyze food images and maps them to Singaporean nutritional data, storing them to `meal_logs` table with schema:
  ```sql
  meal_logs (
    id uuid not null default gen_random_uuid(),
    user_id uuid not null,
    meal text not null,
    description text null,
    created_at timestamp with time zone not null default timezone('utc'::text, now()),
    constraint meal_logs__pkey primary key (id),
    constraint meal_logs__user_id_fkey foreign KEY (user_id) references profiles (id) on delete CASCADE
  )
  ```
- **Clinical Safety:** Checks queries against `medications` and `conditions` before replying.

## 4. API & Security Standards
- **Authentication:** The Frontend sends a Supabase JWT in the `Authorization` header.
- **Backend Auth:** FastAPI dependencies must verify this JWT before processing requests.
- **Secrets:** NEVER output API keys in code. Use `os.getenv("SUPABASE_KEY")` in Python and `Env.supabaseKey` in Dart.

## 5. Coding Style
- **Python:** Type-hint EVERYTHING (`def func(x: int) -> str:`). Use docstrings for complex Agent logic.
- **Dart:** Use `final` variables by default. specific types over `var`.

## 6. Context Injection
- When any Agent runs, it MUST receive the `PatientContext` as an input argument. Never run analysis in a vacuum.
- **PatientContext** includes: first_name, last_name, age, sex, ethnicity, height (cm), activity_level, location, conditions, medications.
- All patient context is automatically included in the chatbot's system prompt for every interaction.





---
description: Specific coding standards for the FastAPI Backend (Python)
globs: ["backend/**/*.py"]
alwaysApply: false
---

# ðŸ Python & FastAPI Rules

## 1. Pydantic v2 Standards
- **Config:** Use `model_config = ConfigDict(...)` instead of `class Config:`.
- **Serialization:** Use `model.model_dump()` instead of `.dict()`.
- **Validation:** Use `@field_validator` instead of `@validator`.

## 2. Agent Architecture
- **Isolation:** Each Agent must have its own file in `app/agents/` (e.g., `analyst_agent.py`).
- **Input:** Agents must accept a typed `State` object (TypedDict or Pydantic).
- **Output:** Agents must return structured JSON, never raw strings.
- **Tools:** Use `@tool` decorator from `langchain_core.tools`.

## 3. Database Interactions
- **ORM:** Use `supabase-py` client directly for simple CRUD.
- **Graph:** Use `Neo4jClient` (from `app.core.neo4j_client`) for medical knowledge graph queries.
- **Async:** All DB calls must be `await`ed. Do not use blocking calls in `async def` routes.
- **Neo4j:** Use synchronous Neo4j driver (neo4j package) within agent functions. Neo4j operations are fast enough to not require async.

## 4. Error Handling
- Use `HTTPException` for API errors.
- Wrap LLM calls in `try/except` blocks to handle timeouts or rate limits.
- Log errors using `logger.error()`, not `print()`.

## 5. Documentation
- All routes must have `summary`, `description`, and `response_model`.
- Complex logic in Agents must be commented with "Why", not just "How".



---
description: Specific coding standards for the Flutter Frontend (Dart)
globs: ["frontend/**/*.dart"]
alwaysApply: false
---

# ðŸ“± Flutter & Dart Rules

## 1. State Management (Riverpod 2.x)
- **Providers:** Always use `@riverpod` code generation.
  - *Bad:* `final myProvider = Provider(...)`
  - *Good:* `@riverpod class MyNotifier extends _$MyNotifier ...`
- **Consumption:** Use `ConsumerWidget` or `ConsumerStatefulWidget`.
- **Async Data:** Always handle `AsyncValue` with `.when()`:
  ```dart
  ref.watch(provider).when(
    data: (data) => ...,
    loading: () => const CircularProgressIndicator(),
    error: (e, st) => Text('Error: $e'),
  );
Side Effects: Use ref.listen for navigation/snackbars, not ref.watch.

2. Networking & Data Layer
Client: Use Dio for all HTTP requests.

Serialization: Use json_serializable or freezed for all models.

Type Safety: NEVER use dynamic. Define strict types for API responses.

Repository Pattern:

Services (API calls) -> Repositories (Data logic) -> Controllers (State) -> UI.

3. UI/UX Standards
Responsiveness: Use LayoutBuilder or MediaQuery sparingly; prefer flexible widgets (Expanded, Flexible).

Text: Use Theme.of(context).textTheme styles. Do not hardcode TextStyle unless absolutely necessary.

Images: Use CachedNetworkImage for all remote URLs.

4. Project Structure
- `lib/models/`: Data classes (Generated from Pydantic schemas in `backend/app/schemas/`).
- `lib/providers/`: Riverpod controllers (using `@riverpod` code generation).
- `lib/screens/`: Feature-specific pages.
- `lib/services/`: API clients and data services (e.g., `database_service.dart`, `chat_stream_service.dart`).
- `lib/widgets/`: Reusable components (Buttons, Cards).

5. Testing
Use flutter_test and mocktail for unit tests.

Mock Repositories, not Providers, when testing UI.